import React from 'react';
import { toast } from 'react-toastify';
import moment from 'moment';
import Button from '@material-ui/core/Button';
import Icon from '@material-ui/core/Icon';
import ListItem from '@material-ui/core/ListItem';
import ListItemText from '@material-ui/core/ListItemText';
import Avatar from '@material-ui/core/Avatar';
import ListItemIcon from '@material-ui/core/ListItemIcon';
import UpdateIcon from '@material-ui/icons/Update';

var updateMessageShown = false;

export default function requestNotificationPermission(props) {
  var auth = props.auth,
      notificationPermissionRequested = props.notificationPermissionRequested,
      setPersistentValue = props.setPersistentValue,
      simpleValues = props.simpleValues,
      setSimpleValue = props.setSimpleValue,
      messaging = props.messaging,
      intl = props.intl,
      appConfig = props.appConfig;


  var reengagingHours = appConfig.notificationsReengagingHours ? appConfig.notificationsReengagingHours : 48;
  var requestNotificationPermission = notificationPermissionRequested ? moment().diff(notificationPermissionRequested, 'hours') > reengagingHours : true;

  if ('Notification' in window && window.Notification.permission !== 'granted' && auth.uid && requestNotificationPermission && !simpleValues['notificationPermissionShown']) {
    setSimpleValue('notificationPermissionShown', true);
    toast.info(function (_ref) {
      var closeToast = _ref.closeToast;
      return React.createElement(
        'div',
        null,
        React.createElement(
          'div',
          { style: { display: 'flex', alignItems: 'center', padding: 8 } },
          React.createElement(
            Icon,
            { style: { paddingRight: 8 }, className: 'material-icons', color: 'secondary' },
            ' ',
            'notifications',
            ' '
          ),
          React.createElement(
            'div',
            { style: { padding: undefined } },
            intl.formatMessage({ id: 'enable_notifications_message' })
          )
        ),
        React.createElement(
          'div',
          { style: { display: 'flex', alignItems: 'center', justifyContent: 'flex-end' } },
          React.createElement(
            Button,
            {
              color: 'primary',
              onClick: function onClick() {
                setPersistentValue('notificationPermissionRequested', moment());
                initializeMessaging(props);
                closeToast();
              }
            },
            intl.formatMessage({ id: 'enable' })
          ),
          React.createElement(
            Button,
            {
              color: 'secondary',
              onClick: function onClick() {
                setPersistentValue('notificationPermissionRequested', moment());
                closeToast();
              }
            },
            intl.formatMessage({ id: 'no_thanks' })
          )
        )
      );
    }, { position: toast.POSITION.TOP_CENTER, autoClose: false, closeButton: false, closeOnClick: false });
  } else if ('Notification' in window && Notification.permission === 'granted' && auth.uid && !messaging.isInitialized) {
    // initializeMessaging(props)
  }
}

export function initializeMessaging(props) {
  var skipIfNoPermission = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var initMessaging = props.initMessaging,
      firebaseApp = props.firebaseApp,
      auth = props.auth;


  firebaseApp.database().ref('disable_notifications/' + auth.uid).once('value', function (snap) {
    if (snap.val()) {
      console.log('Notifications disabled by user');
    } else if (skipIfNoPermission && 'Notification' in window && Notification.permission !== 'granted') {
      console.log('No permissions for Notifications');
    } else {
      console.log('Notifications initialized');
      initMessaging(firebaseApp, function (token) {
        handleTokenChange(props, token);
      }, function (payload) {
        handleMessageReceived(props, payload);
      });
    }
  });
}

export function handleMessageReceived(props, payload) {
  var location = props.location,
      appConfig = props.appConfig;

  var notification = payload.notification;
  var pathname = location ? location.pathname : '';
  var tag = payload.notification ? payload.notification.tag : '';
  var notifications = appConfig.getNotifications(notification, props);
  var notificationData = notifications[tag] ? notifications[tag] : false;

  if (notificationData && pathname.indexOf(notificationData.path) === -1) {
    toast.info(function (_ref2) {
      var closeToast = _ref2.closeToast;
      return getNotification(notificationData, closeToast);
    }, {
      position: toast.POSITION.BOTTOM_RIGHT,
      autoClose: notificationData.autoClose ? notificationData.autoClose : false
    });
  } else {
    toast.info(function (_ref3) {
      var closeToast = _ref3.closeToast;
      return getNotification(notification, closeToast);
    }, {
      position: toast.POSITION.BOTTOM_RIGHT
    });
  }
}

export function handleTokenChange(props, token) {
  var firebaseApp = props.firebaseApp,
      auth = props.auth;


  firebaseApp.database().ref('notification_tokens/' + auth.uid + '/' + token).set(true);
}

export function getNotification(notification, closeToast) {
  if (notification.getNotification) {
    return notification.getNotification(notification, closeToast);
  }

  return createNotifgication(notification, closeToast);
}

export function createNotifgication(notification, closeToast) {
  return React.createElement(
    'div',
    {
      onClick: function onClick() {
        notification.onClick();
      }
    },
    React.createElement(
      ListItem,
      null,
      React.createElement(Avatar, { src: notification.icon }),
      React.createElement(ListItemText, { primary: notification.title, secondary: notification.body })
    )
  );
}

export function checkForUpdate(intl) {
  var title = intl ? intl.formatMessage({ id: 'update_title' }) : 'Update available!';
  var message = intl ? intl.formatMessage({ id: 'update_message' }) : 'Click here to get the new version.';

  if (window.updateAvailable && !updateMessageShown) {
    updateMessageShown = true;
    toast.info(function (_ref4) {
      var closeToast = _ref4.closeToast;
      return React.createElement(
        'div',
        {
          onClick: function onClick() {
            handleUpdate();
          }
        },
        React.createElement(
          ListItem,
          { button: true },
          React.createElement(
            ListItemIcon,
            null,
            React.createElement(UpdateIcon, null)
          ),
          React.createElement(ListItemText, { primary: title, secondary: message })
        )
      );
    }, {
      position: toast.POSITION.BOTTOM_CENTER,
      autoClose: false
    });
  }
}

export function handleUpdate() {
  window.updateAvailable = false;
  window.location.href = window.location.href;
}